# -*- Text; Fundamental; -*-

TODO List
=========

* Make parallel sequence of sound event. (DONE, 
  * Did this by using dseq.
   
* Write SynthDef files. (DONE)
  * Used Data.ByteString.

* Play sound with using synthdefs. (DONE)
  * Write synthdef, and the reload with "/d_loadDir".

* Play parallel sequence with each event having arbitrary
  duration. (DONE)
  * Used tDuty, duty and demand.

* Play synthdef from demand ugens. (DONE)
  * Did in above TODO.

* Make parallel sequence of sound event with using synthdefs. (DONE)
  * Sent trigger from tDuty, and then passed this trigger signal to
    ugen with envelope. This will trigger the envelope, thus makes sound.

* Use "n_map" instead of using "In" UGen. (DONE)
  * See "ParallelSeq4".

* Instantiate UGen from Data and Typeable. (DONE)
  * See "Instances.hs". Wrote by hand.

* Create node graphs with adding each node with grouping. (DONE)
  * See "ParallelSeq4".

* Control parameters of graph, like effects, amplitude, etc. Both node
  and group.

* Use dbufrd instead of dseq for passing parameters. (DONE, but...)
  * See "ParallelSeq4". Though could be improved concerning the use of
    index. ParallelSeq4 uses stepper ugen, and resetting is not
    working as desired. Control bus value is sometime overwritten by
    the ugen, sometime not.

* Add "resting" to sequence of notes.

* Rewrite acid example using haskell.

* Write DSL for mapping nodes ... its tedious thing to do.

* Find efficient way for bookkeeping of nodeID, busID, buffeerID.

* Recieve MIDI event from other app, device.

* Write event scheduling library in haskell.
