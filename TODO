# -*- mode: Text; Fill; Fundamental; -*-

NOTES
=====
* Some function for Events are unstable for usid as timing control of
  realtime musical performance. e.g. filterE, Behavior

* Found explanation of control args starting with "t_" in help file of
  Synthdef.

* SuperCollider's pbind sends new synth with POSITIVE node id. This
  should doing some trick for releasing the gate after the synth is created.

* Nesting of patterns seemed as using Data.Tree and flattening with
  toList... Is it? 

* Read SC Tutorial in help files, and translate in haskell.
  * Getting started with SC (READ, but write buffer examples again)
  * Introductory Tutorial (READ, Implemented scheduling examples with Event)
  * Tutorial (READ)
  * Tour of Unit Generators (READ)
  * A Practical Guide to Patterns (currently only taking a glance)
    * PG_01_Introduction (READ)
    * PG_02_Basic_Vocabulary (READ)
    * PG_03_What_Is_Pbind (READ)
    * PG_04_Words_to_Phrases (READ)
    * PG_05_Math_on_patterns (READ)
    * PG_06_Filter_Patterns (READ)
    * PG_06a_Repetition_Contraint_Patterns (READ)
    * PG_06b_Time_Based_Patterns (READ)
    * PG_06c_Composition_of_Patterns (READ)
    * PG_06d_Parallel_Patterns
    * PG_06e_Language_Control
    * PG_06f_Server_Control
    * PG_06g_Data_Sharing
    * PG_07_Value_Conversions
    * PG_08_Event_Types_and_Parameters
    * PG_Cookbook01_
    * ...

* Write DSL for get/set/add/free, or in other word, CRUD.
  * Inspired by realworldhaskel, something like below. (Is it possible?)
    > query (bufid ==? 3)
    > update (bufid ==? 3) (0,[1,2,3,4,5]) 
    > query (busid ==? 1) 
    > query (name ==? "foo")
    > update (name ==? "foo" &&? param ==? "amp") 0.1 
    > free (nid ==? 2)
    > add 1 "foo" [freq := 440] -- target groupId, synth, params
  * ... After writing few lines of scratch, feeling that above
    language design is not so efficient.

DONE
====

* Instantiate UGen from Data and Typeable. (DONE, but...)
  * See "Instances.hs". Wrote by hand. Could be improved.

* Make parallel sequence of sound event. (DONE) 
  * Did this by using dseq.
  * Did again with pauseThread (threadDelay with bit of calc) and
    Event from FRP.Reactive. With using Event datatype and wrapping
    OSC message, writing to file for NRT rendering wouldn't be so
    hard, perhaps.
   
* Write SynthDef files. (DONE)
  * Used Data.ByteString.

* Play sound with using synthdefs. (DONE)
  * Write synthdef, and the reload with "/d_loadDir".

* Play parallel sequence with each event having arbitrary
  duration. (DONE)
  * Used tDuty, duty and demand.

* Play synthdef from demand ugens. (DONE)
  * Did in above TODO.

* Make parallel sequence of sound event with using synthdefs. (DONE)
  * Sent trigger from tDuty, and then passed this trigger signal to
    ugen with envelope. This will trigger the envelope, thus makes sound.

* Use "n_map" instead of using "In" UGen. (DONE)
  * See "ParallelSeq4".

* Write DSL for mapping nodes ... its tedious thing to do. (DONE)
  * Used monadic style shown in pearl.pdf, by Graham and Meijer.

* Create node graphs with adding each node with grouping. (DONE)
  * See "ParallelSeq4".

* Control parameters of graph, like effects, amplitude, etc. Both node
  and group. (DONE)
  * Use "/n_set" message or, "/c_set" and map to control busses.

* Write "showTree" function for SCTree. (DONE)
  * Convertd to Data.Tree.Tree and used Data.Tree.drawTree.

* Read "Architecture" section in sc help file. (DONE)

* Use dbufrd instead of dseq for passing parameters. (DONE, but...)
  * See "ParallelSeq4". Though could be improved in use of
    index. ParallelSeq4 uses stepper ugen, and resetting is not
    working as desired. Control bus value is sometime overwritten by
    the ugen, sometime not.

