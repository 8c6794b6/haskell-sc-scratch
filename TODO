# -*- mode: Text; Fill; Fundamental; -*-

TODO List
=========

* Use dbufrd instead of dseq for passing parameters. (DONE, but...)
  * See "ParallelSeq4". Though could be improved in use of
    index. ParallelSeq4 uses stepper ugen, and resetting is not
    working as desired. Control bus value is sometime overwritten by
    the ugen, sometime not.

* Read SC Tutorial in help files, and translate in haskell.
  * Getting started with SC (READ, but write buffer examples again)
  * Introductory Tutorial (READ, Implemented scheduling examples with Event)
  * Tutorial
  * Tour of Unit Generators
  * A Practical Guide to Patterns
  * Streams Overview

* Read "Architecture" section in sc help file.

* Write some example shown in SC help. Listen carefully that the
  haskell version is making same sound as SC version. Use both sclang
  and hsc3. Especially synth and effect mapping using synthdefs.

* Instantiate UGen from Data and Typeable. (DONE, but...)
  * See "Instances.hs". Wrote by hand. Could be improved.

* Write implementation of function for buffer written in Reusable.hs.

* Change the name of Reusable.hs, or move to other place.
  * How about Misc?

* Write DSL for get/set/add/free, or in other word, CRUD.
  * Inspired by realworldhaskel, something like below. (Is it possible?)
    > query (bufid ==? 3)
    > update (bufid ==? 3) (0,[1,2,3,4,5]) 
    > query (busid ==? 1) 
    > query (name ==? "foo")
    > update (name ==? "foo" &&? param ==? "amp") 0.1 
    > free (nid ==? 2)
    > add 1 "foo" [freq := 440] -- target groupId, synth, params

* Rewrite acid example using haskell.

* Find efficient way for bookkeeping nodeID, busID, buffeerID.

* Rewrite sc examples from distribution in haskell . It's in
  ~/share/SuperCollider/examples/. Mac OSX specific examples could be ignored.

* Recieve MIDI event from other app

* Recieve MIDI event from device.

* Write concurrent event scheduling library in haskell.
  * Enable below from ghci session
    * Add thread 
    * Show current threads and status 
    * Pause thread
    * Restart thread 
    * Kill, or remove thread
  * ... should I use haskeline and implement this in specific interpreter?

DONE
====

* Make parallel sequence of sound event. (DONE) 
  * Did this by using dseq.
  * Did again with pauseThread (threadDelay with bit of calc) and
    Event from FRP.Reactive.
   
* Write SynthDef files. (DONE)
  * Used Data.ByteString.

* Play sound with using synthdefs. (DONE)
  * Write synthdef, and the reload with "/d_loadDir".

* Play parallel sequence with each event having arbitrary
  duration. (DONE)
  * Used tDuty, duty and demand.

* Play synthdef from demand ugens. (DONE)
  * Did in above TODO.

* Make parallel sequence of sound event with using synthdefs. (DONE)
  * Sent trigger from tDuty, and then passed this trigger signal to
    ugen with envelope. This will trigger the envelope, thus makes sound.

* Use "n_map" instead of using "In" UGen. (DONE)
  * See "ParallelSeq4".

* Write DSL for mapping nodes ... its tedious thing to do. (DONE)
  * Used monadic style shown in pearl.pdf, by Graham and Meijer.

* Create node graphs with adding each node with grouping. (DONE)
  * See "ParallelSeq4".

* Control parameters of graph, like effects, amplitude, etc. Both node
  and group. (DONE)
  * Use "/n_set" message or, "/c_set" and map to control busses.

* Write "showTree" function for SCTree. (DONE)
  * Convertd to Data.Tree.Tree and used Data.Tree.drawTree.

BURIED
======

* Add "resting" to sequence of notes. (NOT ENOUGH CONCRETE.)
